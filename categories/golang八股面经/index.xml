<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Golang八股面经 on yuxiay的博客</title><link>https://yuxiay.github.io/categories/golang%E5%85%AB%E8%82%A1%E9%9D%A2%E7%BB%8F/</link><description>Recent content in Golang八股面经 on yuxiay的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sun, 06 Apr 2025 23:25:36 +0800</lastBuildDate><atom:link href="https://yuxiay.github.io/categories/golang%E5%85%AB%E8%82%A1%E9%9D%A2%E7%BB%8F/index.xml" rel="self" type="application/rss+xml"/><item><title>Redis缓存穿透、击穿、雪崩</title><link>https://yuxiay.github.io/p/redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E9%9B%AA%E5%B4%A9/</link><pubDate>Sun, 06 Apr 2025 23:25:36 +0800</pubDate><guid>https://yuxiay.github.io/p/redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E9%9B%AA%E5%B4%A9/</guid><description>&lt;h3 id="redis"&gt;Redis
&lt;/h3&gt;&lt;p&gt;设计&lt;a class="link" href="http://mp.weixin.qq.com/s?__biz=MzU5NTAzNjM0Mw==&amp;amp;mid=2247485849&amp;amp;idx=2&amp;amp;sn=a85a71485fc64bf34e5f1e4971dc2469&amp;amp;chksm=fe795841c90ed157f347ef6b0bccdb7aa5e49cade80eb9a5be96329cd8f813d06e4b335cfdac&amp;amp;scene=21#wechat_redirect" target="_blank" rel="noopener"
&gt;一个缓存系统&lt;/a&gt;，不得不要考虑的问题就是：缓存穿透、&lt;a class="link" href="https://so.csdn.net/so/search?q=%e7%bc%93%e5%ad%98%e5%87%bb%e7%a9%bf&amp;amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener"
&gt;缓存击穿&lt;/a&gt;与失效时的雪崩效应。&lt;/p&gt;
&lt;p&gt;前台请求，后台先从缓存中取数据，取到直接返回结果，取不到时从数据库中取，数据库取到更新缓存，并返回结果，数据库也没取到，那直接返回空结果。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://yuxiay.github.io/p/redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E9%9B%AA%E5%B4%A9/2306e5245ce0e0eae6d4222497145422.png"
width="447"
height="308"
srcset="https://yuxiay.github.io/p/redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E9%9B%AA%E5%B4%A9/2306e5245ce0e0eae6d4222497145422_hu_e6d3703a0e121838.png 480w, https://yuxiay.github.io/p/redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E9%9B%AA%E5%B4%A9/2306e5245ce0e0eae6d4222497145422_hu_1a5b40c9068d4bdf.png 1024w"
loading="lazy"
alt="img"
class="gallery-image"
data-flex-grow="145"
data-flex-basis="348px"
&gt;&lt;/p&gt;
&lt;h4 id="缓存穿透"&gt;&lt;strong&gt;缓存穿透&lt;/strong&gt;
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;描述：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ 缓存穿透是指&lt;strong&gt;缓存和数据库中都没有的数据&lt;/strong&gt;，而用户不断发起请求。由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。&lt;/p&gt;
&lt;p&gt;在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。&lt;/p&gt;
&lt;p&gt;如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;接口层增加校验&lt;/strong&gt;，如用户鉴权校验，id做基础校验，id&amp;lt;=0的直接拦截；&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为&lt;strong&gt;key-null&lt;/strong&gt;，&lt;strong&gt;缓存有效时间可以设置短点&lt;/strong&gt;，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id="缓存击穿"&gt;&lt;strong&gt;缓存击穿&lt;/strong&gt;
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;描述：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;*缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期）*&lt;/strong&gt;&lt;/em&gt;，这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、设置热点数据永远不过期。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;**2、接口限流与熔断，降级。**重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要降级准备，当接口中的某些 服务 不可用时候，进行熔断，失败快速返回机制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、布隆过滤器&lt;/strong&gt;**。**bloomfilter就类似于一个hash set，用于快速判某个元素是否存在于集合中，其典型的应用场景就是快速判断一个key是否存在于某容器，不存在就直接返回。布隆过滤器的关键就在于hash算法和容器大小，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、加互斥锁&lt;/strong&gt;，互斥锁参考代码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src="https://yuxiay.github.io/p/redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E9%9B%AA%E5%B4%A9/bc102cffc045560db428049ff48e206e.png"
width="762"
height="571"
srcset="https://yuxiay.github.io/p/redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E9%9B%AA%E5%B4%A9/bc102cffc045560db428049ff48e206e_hu_ccb83b996183e970.png 480w, https://yuxiay.github.io/p/redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E9%9B%AA%E5%B4%A9/bc102cffc045560db428049ff48e206e_hu_d124f1233a018111.png 1024w"
loading="lazy"
alt="img"
class="gallery-image"
data-flex-grow="133"
data-flex-basis="320px"
&gt;&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;​ 1）缓存中有数据，直接走上述代码13行后就返回结果了&lt;/p&gt;
&lt;p&gt;​ 2）缓存中没有数据，第1个进入的线程，获取锁并从数据库去取数据，没释放锁之前，其他并行进入的线程会等待100ms，再重新去缓存取数据。这样就防止都去数据库重复取数据，重复往缓存中更新数据情况出现。&lt;/p&gt;
&lt;p&gt;​ 3）当然这是简化处理，理论上如果能根据key值加锁就更好了，就是线程A从数据库取key1的数据并不妨碍线程B取key2的数据，上面代码明显做不到这点。&lt;/p&gt;
&lt;h4 id="缓存雪崩"&gt;&lt;strong&gt;缓存雪崩&lt;/strong&gt;
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;描述：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://so.csdn.net/so/search?q=%e7%bc%93%e5%ad%98%e9%9b%aa%e5%b4%a9&amp;amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener"
&gt;缓存雪崩&lt;/a&gt;是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是， 缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。&lt;/li&gt;
&lt;li&gt;如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。&lt;/li&gt;
&lt;li&gt;设置热点数据永远不过期。&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>go内存逃逸</title><link>https://yuxiay.github.io/p/go%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8/</link><pubDate>Sun, 23 Mar 2025 23:25:36 +0800</pubDate><guid>https://yuxiay.github.io/p/go%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8/</guid><description>&lt;h2 id="go内存分配与逃逸分析"&gt;go内存分配与逃逸分析
&lt;/h2&gt;&lt;p&gt;内存管理主要包括俩个动作：分配与释放&lt;/p&gt;
&lt;p&gt;逃逸分析是服务与内存分配的&lt;/p&gt;
&lt;p&gt;而内存的释放由GC负责&lt;/p&gt;
&lt;h4 id="栈"&gt;栈
&lt;/h4&gt;&lt;p&gt;在go语言中，&lt;strong&gt;栈的内存是由编译器自动进行分配和释放的&lt;/strong&gt;，栈区往往存储着函数参数，局部变量和调用函数帧，&lt;strong&gt;它们随着函数的创建而分配，随着函数的退出而销毁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;go应用程序运行时，每个goroutine都维护着一个自己的栈区，这个栈区只能自己使用而不能被其它goroutine使用。栈是调用栈(call stack)的简称。&lt;strong&gt;一个栈通常又包含了许多栈帧，它描述的是函数之间的调用关系&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id="堆"&gt;堆
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;与栈不同的是，堆区的内存一般是由编译器和工程师自己共同进行分配管理的，交给Runtime GC来释放。在堆上分配时，必须找到一块足够大的内存来存放新的变量数据。后续释放时，垃圾回收期扫描堆空间寻找不再被使用的对象&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id="逃逸分析"&gt;逃逸分析
&lt;/h4&gt;&lt;p&gt;相比于把内存分配到堆上，分配到栈中优势更加明显&lt;/p&gt;
&lt;p&gt;Go编译器会尽可能将变量分配到栈上&lt;/p&gt;
&lt;p&gt;但是在函数返回后无法证明变量未被引用，则该变量将被分配到堆上，该变量不随函数栈的回收而回收，以此来避免悬挂指针的问题&lt;/p&gt;
&lt;p&gt;如果变量占用内存大也会放入堆上&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Go是如何确定内存是分配到栈上还是堆上呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答案就是：&lt;strong&gt;内存逃逸&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;编译器通过逃逸分析技术来选择堆或者栈，逃逸分析的基本思想如下：&lt;strong&gt;检查变量的生命周期是否完全可知的，如果通过检查，则在栈上分配，否则就是所谓逃逸，必须在堆上进行分配&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id="逃逸分析原则"&gt;逃逸分析原则
&lt;/h4&gt;&lt;p&gt;Go语言虽然没有明确说明逃逸分析原则，但有以下几点准则是可以参考的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不同于JAVA JVM的运行时逃逸分析，Go的逃逸分析是在编译期完成的：编译期无法确定的参数类型必定放到堆中&lt;/li&gt;
&lt;li&gt;如果变量在函数外部存在引用，则必定放在堆中&lt;/li&gt;
&lt;li&gt;如果变量占用内存较大时，则优先放到堆中&lt;/li&gt;
&lt;li&gt;如果变量在函数外部没有引用，则优先放到栈中&lt;/li&gt;
&lt;li&gt;变量大小无法确定时也会发生内存逃逸&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>go语言垃圾回收</title><link>https://yuxiay.github.io/p/go%E8%AF%AD%E8%A8%80%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</link><pubDate>Sun, 23 Mar 2025 23:25:36 +0800</pubDate><guid>https://yuxiay.github.io/p/go%E8%AF%AD%E8%A8%80%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</guid><description>&lt;h3 id="go语言垃圾回收"&gt;Go语言——垃圾回收
&lt;/h3&gt;&lt;p&gt;屏障：
1.插入屏障：在A对象引用B对象的时候，B对象被标记为灰色（满足强三色不变式，黑色引用的白色对象会被强制转换为灰色）。只有堆上的对象触发插入屏障，栈上的对象不触发插入屏障。在准备回收白色前，重新遍历扫描一次栈空间。此时加STW暂停保护栈，防止外界干扰。&lt;/p&gt;
&lt;p&gt;不足：结束时需要使用STW来重新扫描栈&lt;/p&gt;
&lt;p&gt;2.删除屏障：被删除的对象，如果自身为灰色或者白色，那么被标记为灰色（满足弱三色不变式）。&lt;/p&gt;
&lt;p&gt;删除屏障的不足：回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉。&lt;/p&gt;
&lt;p&gt;Go V1.8的三色标记法+混合写屏障机制
具体操作：
1.GC开始将栈上的可达对象全部扫描并标记为黑色（之后不再进行第二次重复扫描，无需STW）
2.GC期间，任何在栈上创建的新对象，均为黑色
3.堆上被删除对象标记为灰色
4.堆上被添加的对象标记为灰色
满足：变形的弱三色不变式（结合了插入、删除写屏障的优点）&lt;/p&gt;
&lt;p&gt;对于堆上的对象，采用三色标记法+写屏障保护&lt;/p&gt;
&lt;h4 id="gc垃圾收集的多个阶段"&gt;GC垃圾收集的多个阶段：
&lt;/h4&gt;&lt;p&gt;1.标记准备阶段；&lt;/p&gt;
&lt;p&gt;启动后台标记任务
暂停程序（STW），所有的处理器在这时会进入安全点（Safe point）；
如果当前垃圾收集循环是强制触发的，我们还需要处理还未被清理的内存管理单元；
将根对象入队
开启写屏障
2.标记阶段；&lt;/p&gt;
&lt;p&gt;恢复用户协程
使用三色标记法开始标记，此时用户协程和标记协程并发执行
3.标记终止阶段；&lt;/p&gt;
&lt;p&gt;暂停用户协程
计算下一次触发GC时需要达到的堆目标
唤醒后台清扫协程
4.清理阶段；&lt;/p&gt;
&lt;p&gt;关闭写屏障
恢复用户协程
异步清理回收&lt;/p&gt;
&lt;h4 id="什么是根对象"&gt;什么是根对象？
&lt;/h4&gt;&lt;p&gt;根对象（root object）是指那些能够从全局可达的地方访问到的对象。垃圾回收器会从根对象开始，通过遍历根对象的引用关系，逐步追踪并标记所有可达的对象。任何未被标记的对象都会被认为是垃圾，最终被回收释放。&lt;/p&gt;
&lt;p&gt;1.全局变量：全局变量可以被程序中的任何位置引用到，因此是根对象。
2.当前正在执行的函数的局部变量：当一个函数正在执行时，其局部变量可以被当前函数中的代码访问到，因此也是根对象。
3.当前正在执行的 goroutine 的栈中的变量：goroutine 是 Go语言并发编程中的轻量级线程，每个 goroutine 都有一块独立的栈空间，其中的变量可以被当前 goroutine 访问到，也是根对象。
4.其他和运行时系统相关的数据结构和变量。&lt;/p&gt;
&lt;h4 id="三色标记法的缺点"&gt;三色标记法的缺点：
&lt;/h4&gt;&lt;p&gt;1.暂停时间：在进行垃圾回收时，必须停止程序执行，这会导致应用程序暂停。引入写屏障保护可以减少暂停时间，
但仍然可能导致性能下降。
2.内存开销：三色标记法需要为每个对象维护额外的状态信息，以记录其标记状态。这会增加内存开销，并可能对内
存资源造成负担。
3.频繁的垃圾回收：三色标记法需要频繁地迭代标记和清除对象，如果要回收的垃圾对象很多，可能会导致回收过程
变得非常耗时。
4.碎片化：垃圾回收过程中，如果频繁进行对象的移动和重新分配内存，可能会导致内存碎片化，降低内存的利用
率。&lt;/p&gt;
&lt;h4 id="gc的触发条件"&gt;GC的触发条件
&lt;/h4&gt;&lt;p&gt;1.主动触发(手动触发)，通过调用 runtime.GC 来触发GC，此调用阻塞式地等待当前GC运行完毕。
2.被动触发，分为两种方式：&lt;/p&gt;
&lt;p&gt;2.1.使用步调（Pacing）算法，其核心思想是控制内存增长的比例,每次内存分配时检查当前内存分配量是否已达到阈值（环境变量GOGC）：默认100%，即当内存扩大一倍时启用GC。
2.2.使用系统监控，当超过两分钟没有产生任何GC时，强制触发 GC。&lt;/p&gt;
&lt;h4 id="gc调优"&gt;GC调优
&lt;/h4&gt;&lt;p&gt;1.控制内存分配的速度，限制Goroutine的数量，提高赋值器mutator的CPU利用率（降低GC的CPU利用率）
2.少量使用+连接string
3.slice提前分配足够的内存来降低扩容带来的拷贝
4.避免map key对象过多，导致扫描时间增加
5.变量复用，减少对象分配，例如使用sync.Pool来复用需要频繁创建临时对象、使用全局变量等
6.增大GOGC的值，降低GC的运行频率&lt;/p&gt;</description></item></channel></rss>